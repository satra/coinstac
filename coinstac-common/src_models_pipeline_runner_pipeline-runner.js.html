<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/models/pipeline/runner/pipeline-runner.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a><ul class='methods'><li data-type='method'><a href="Base.html#serialize">serialize</a></li><li data-type='method'><a href="Base.html#toJSON">toJSON</a></li></ul></li><li><a href="CommandComputation.html">CommandComputation</a><ul class='methods'><li data-type='method'><a href="CommandComputation.html#run">run</a></li><li data-type='method'><a href="CommandComputation.html#serialize">serialize</a></li><li data-type='method'><a href="CommandComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="Computation.html">Computation</a><ul class='methods'><li data-type='method'><a href="Computation.html#.factory">factory</a></li><li data-type='method'><a href="Computation.html#run">run</a></li><li data-type='method'><a href="Computation.html#serialize">serialize</a></li><li data-type='method'><a href="Computation.html#toJSON">toJSON</a></li></ul></li><li><a href="ComputationRegistry.html">ComputationRegistry</a><ul class='methods'><li data-type='method'><a href="ComputationRegistry.html#.getNameAndVersion">getNameAndVersion</a></li><li data-type='method'><a href="ComputationRegistry.html#add">add</a></li><li data-type='method'><a href="ComputationRegistry.html#all">all</a></li><li data-type='method'><a href="ComputationRegistry.html#get">get</a></li><li data-type='method'><a href="ComputationRegistry.html#remove">remove</a></li></ul></li><li><a href="ComputationResult.html">ComputationResult</a><ul class='methods'><li data-type='method'><a href="ComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="ComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="Consortium.html">Consortium</a><ul class='methods'><li data-type='method'><a href="Consortium.html#.compareUsernames">compareUsernames</a></li><li data-type='method'><a href="Consortium.html#hasMember">hasMember</a></li><li data-type='method'><a href="Consortium.html#isOwnedBy">isOwnedBy</a></li><li data-type='method'><a href="Consortium.html#serialize">serialize</a></li><li data-type='method'><a href="Consortium.html#toJSON">toJSON</a></li></ul></li><li><a href="DBListener.html">DBListener</a><ul class='methods'><li data-type='method'><a href="DBListener.html#destroy">destroy</a></li></ul></li><li><a href="DecentralizedComputation.html">DecentralizedComputation</a><ul class='methods'><li data-type='method'><a href="DecentralizedComputation.html#serialize">serialize</a></li><li data-type='method'><a href="DecentralizedComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="File.html">File</a><ul class='methods'><li data-type='method'><a href="File.html#serialize">serialize</a></li><li data-type='method'><a href="File.html#toJSON">toJSON</a></li></ul></li><li><a href="JavascriptComputation.html">JavascriptComputation</a><ul class='methods'><li data-type='method'><a href="JavascriptComputation.html#run">run</a></li><li data-type='method'><a href="JavascriptComputation.html#serialize">serialize</a></li><li data-type='method'><a href="JavascriptComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalComputationResult.html">LocalComputationResult</a><ul class='methods'><li data-type='method'><a href="LocalComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="LocalComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalPipelineRunner.html">LocalPipelineRunner</a><ul class='methods'><li data-type='method'><a href="LocalPipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="LocalPipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="LocalPipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="LocalPipelineRunner.html#run">run</a></li><li data-type='method'><a href="LocalPipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="LocalPipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="LocalPipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalPipelineRunnerPool.html">LocalPipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="LocalPipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getLatestResult">getLatestResult</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getLocalResult">getLocalResult</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="Pipeline.html">Pipeline</a><ul class='methods'><li data-type='method'><a href="Pipeline.html#run">run</a></li><li data-type='method'><a href="Pipeline.html#serialize">serialize</a></li><li data-type='method'><a href="Pipeline.html#toJSON">toJSON</a></li></ul></li><li><a href="PipelineRunner.html">PipelineRunner</a><ul class='methods'><li data-type='method'><a href="PipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="PipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="PipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="PipelineRunner.html#run">run</a></li><li data-type='method'><a href="PipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="PipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="PipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="PipelineRunnerPool.html">PipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="PipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="PipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="PipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="PipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="PipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="PipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="PipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="PipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="PipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="PipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="PipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="PipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="PouchDocument.html">PouchDocument</a><ul class='methods'><li data-type='method'><a href="PouchDocument.html#serialize">serialize</a></li><li data-type='method'><a href="PouchDocument.html#toJSON">toJSON</a></li></ul></li><li><a href="Project.html">Project</a><ul class='methods'><li data-type='method'><a href="Project.html#serialize">serialize</a></li><li data-type='method'><a href="Project.html#toJSON">toJSON</a></li></ul></li><li><a href="RemoteComputationResult.html">RemoteComputationResult</a><ul class='methods'><li data-type='method'><a href="RemoteComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="RemoteComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="RemotePipelineRunner.html">RemotePipelineRunner</a><ul class='methods'><li data-type='method'><a href="RemotePipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getUserErrors">getUserErrors</a></li><li data-type='method'><a href="RemotePipelineRunner.html#run">run</a></li><li data-type='method'><a href="RemotePipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="RemotePipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="RemotePipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="RemotePipelineRunnerPool.html">RemotePipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="RemotePipelineRunnerPool.html#buildNewRemoteResult">buildNewRemoteResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getLatestResult">getLatestResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getRemoteResult">getRemoteResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="User.html">User</a><ul class='methods'><li data-type='method'><a href="User.html#serialize">serialize</a></li><li data-type='method'><a href="User.html#toJSON">toJSON</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-services_computation-registry-factory.html">services/computation-registry-factory</a><ul class='methods'><li data-type='method'><a href="module-services_computation-registry-factory.html#~computationRegistryFactory">computationRegistryFactory</a></li></ul></li><li><a href="module-services_db-registry.html">services/db-registry</a><ul class='methods'><li data-type='method'><a href="module-services_db-registry.html#~dbRegistryFactory">dbRegistryFactory</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="DBListener.html#event:change">change</a></li><li><a href="DBListener.html#event:delete">delete</a></li><li><a href="LocalPipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="LocalPipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="LocalPipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="LocalPipelineRunnerPool.html#event:ready">ready</a></li><li><a href="LocalPipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="LocalPipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="LocalPipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="LocalPipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="LocalPipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="LocalPipelineRunnerPool.html#event:run:start">run:start</a></li><li><a href="Pipeline.html#event:save-request">save-request</a></li><li><a href="PipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="PipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="PipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="PipelineRunnerPool.html#event:ready">ready</a></li><li><a href="PipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="PipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="PipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="PipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="PipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="PipelineRunnerPool.html#event:run:start">run:start</a></li><li><a href="RemotePipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="RemotePipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="RemotePipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="RemotePipelineRunnerPool.html#event:ready">ready</a></li><li><a href="RemotePipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="RemotePipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="RemotePipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="RemotePipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="RemotePipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="RemotePipelineRunnerPool.html#event:run:start">run:start</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cleanupTestDir">cleanupTestDir</a></li><li><a href="global.html#filterComputation">filterComputation</a></li><li><a href="global.html#getMockComputations">getMockComputations</a></li><li><a href="global.html#localResultOpts">localResultOpts</a></li><li><a href="global.html#MOCK_COMPUTATION_PATH">MOCK_COMPUTATION_PATH</a></li><li><a href="global.html#remoteResultOpts">remoteResultOpts</a></li><li><a href="global.html#seedInstanceComputations">seedInstanceComputations</a></li><li><a href="global.html#setupNetworkStubs">setupNetworkStubs</a></li><li><a href="global.html#setupTestDir">setupTestDir</a></li><li><a href="global.html#TEST_COMPUTATION_PATH">TEST_COMPUTATION_PATH</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">src/models/pipeline/runner/pipeline-runner.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const Base = require('../../base');
const EventEmitter = require('events').EventEmitter;
const Pipeline = require('../pipeline');
const ComputationResult = require('../../computation/computation-result');
const joi = require('joi');
const assign = require('lodash/assign');
const extractRunId = ComputationResult.prototype._extractRunId;

/**
 * @abstract
 * @class PipelineRunner
 * @extends Base
 * @description responds to events from a PipelineRunnerPool.  specifically, it
 * collects the latest document state from local result and/or remote result
 * stores, and triggers Pipeline activity.  PipelineRunner both initiates
 * the running of a Pipeline and it "awakens" a halted Pipeline by calling
 * Pipeline.run.  Pipeline.run is called only when the PipelineRunner _itself_
 * has been awakend by the PipelineRunnerPool, and once it has finished
 * collecting a Pipeline's required inputs.  Lastly, the PipelineRunner is
 * responsible for persisting the computation results and pipeline state.
 * @property {EventEmitter} events
 * @property {Pipeline} pipeline
 * @property {ComputationResult} result
 */
class PipelineRunner extends Base {
  constructor(opts) {
    super(opts);
    this.events = new EventEmitter();
    this.events.setMaxListeners(20);
    this.pipeline.events.on('save-request', this._handleSaveRequest.bind(this));
  }

  /**
   * PipelineRunner does not persist state after run completes, as the
   * computation returned undefined/null
   *
   * @event PipelineRunner#noop:noData
   * @type {ComputationResult}
   */

  /**
   * @description get previous result data from db
   * @param {Pouchy} db
   * @returns {Promise} Resolves to a data object or null
   */
  getPreviousResultData(db) {
    /* istanbul ignore next */
    if (!db) { throw new ReferenceError('missing db'); }
    const runId = extractRunId(this.result._id);
    return this.findResultByRunId(db, runId)
    .then((doc) => {
      if (!doc) { return null; }
      return doc.data;
    });
  }

  /**
   * @description finds all result docs in a provided db matching provided runId
   * @param {Pouchy} db
   * @param {string} runId
   * @returns {Promise}
   */
  getResultDocs(db, runId) {
    const re = new RegExp(`^${runId}`);

    // db.all({ include_docs: false })
    // .then(lightDocs => lightDocs.filter(lDoc => lDoc._id.match(re)))
    // .then(lightDocs => db.bulkGet(lightDocs))
    // .then(docs => cb(null, docs))
    // .catch(cb);
    // @TODO get bulkGet ^^ working for improved efficency (`.all()` ==> heavy)
    return db.all()
    .then((docs) => docs.filter(doc => doc._id.match(re)));
  }

  /**
   * Write pipeline results to db.
   * @private
   * @param {ComputationResult} rslt local or remote.
   * @returns {Promise}
   */
  _handleSaveRequest(rslt, err, force) {
    // local runners only write results to `runner.db`, and
    // remote runners only write results to `runner.remoteDB`, hence we can
    // objectively select which db to write to by existence of attrs on the runner
    const db = this.db || this.remoteDB;
    /* istanbul ignore if */
    if (!db) {
      throw new ReferenceError('expected db to write computation results into');
    }
    return this.saveResult(db, rslt, err, force);
  }

  /**
   * complete a pipeline run or run attempt.
   * @private
   * @returns {Promise}
   */
  _flush() {
    return (this._saveQueue || Promise.resolve()) // wait for saves to settle out
    .then(() => {
      this.events.emit('halt', this.result);
      return this.result;
    });
  }

  /**
   * @description finds a result document matching the provided runId in the
   *              provided db
   * @param {Pouchy} db
   * @param {string} runId
   * @param {cb} cb(err, {null|object})
   * @returns {Promise}
   */
  findResultByRunId(db, runId) {
    return db.all({ include_docs: false })
    .then((docs) => docs.find(doc => doc._id.match(runId)))
    .then((doc) => {
      if (!doc) { return Promise.resolve(); }
      return db.get(doc._id);
    });
  }

  _generateResultPatch(runData, runError) {
    const patch = {
      pipelineState: {
        inProgress: this.pipeline.inProgress,
        step: this.pipeline.step,
      },
      pluginState: this.result.pluginState,
    };

    // squash data state only when a computation returns data
    if (runData !== null &amp;&amp; runData !== undefined) {
      assign(patch, { data: runData });
    }

    // apply `error` state _only_ when the most recent run has errored
    delete this.result.error;
    if (runError) {
      assign(patch, {
        error: {
          message: runError.message,
          stack: runError.stack,
        },
      });
    }
    return patch;
  }

  /**
   * @description updates or creates the result doc for a user provided
   * db with the data returned from the pipeline computation
   * @note we queue saveResult requests to ensure that prior state has
   * saved before next pipeline state attemps to save
   * @param {Pouchy} db
   * @param {object} runData computation response
   * @param {Error} runError runtime Error
   * @param {function} force persist even when data &amp; error content are empty.
   *                         useful when pipelineState or pluginState may demand
   *                         persistence
   * @returns {Promise}
   */
  saveResult(db, runData, runError, force) {
    /* istanbul ignore if */
    if (!db) { throw new ReferenceError('saveResult requires a db'); }

    const isNoOp = !force &amp;&amp; !runError &amp;&amp; (runData === null || runData === undefined);

    // for simplicity sake, always save on first request.
    // don't bother persisting if no data or no error occurred
    // this is how we support algorithms that say "noop"
    if (this.result._rev &amp;&amp; isNoOp) {
      this.events.emit('noop:noData', this.result);
      return Promise.resolve(this.result);
    }

    // define how our ComputationResult has changed in the form of a `patch`
    const patch = this._generateResultPatch(runData, runError);
    if (!this._saveQueue) { this._saveQueue = Promise.resolve(); }
    this._saveQueue = this._saveQueue.then(() => this._saveResult(db, patch));
    return this._saveQueue;
  }

  /**
   * See `saveResult`.  `saveResult` is the interface for saving
   * a result, however, merely stages result save requests into the save queue
   * @private
   * @param {Pouchy} db
   * @param {object} patch key value pairs to update our current result doc with
   * @returns {Promise}
   */
  _saveResult(db, patch) {
    /* istanbul ignore next */
    if (!db) { return new ReferenceError('PipelineRunner saveResult requires db'); }
    /* istanbul ignore next */
    if (!patch) { return new ReferenceError('PipelineRunner saveResult requires result patch'); }

    // find DB copy of our result document, then patch it
    const runId = extractRunId(this.result._id);
    return this.findResultByRunId(db, runId)
    .then((doc) => this._updateResult(db, patch, doc))
    .catch((err) => {
      this.events.emit('error', err);
      throw err;
    });
  }

  /**
   * Handles case where we were requested to save/update a result
   * document, but none was found.  this case is _expected_ each time we kick of
   * a Pipeline cycle in any environment, as no result exists on init
   * @private
   * @param {Pouchy} db
   * @param {object} patch document
   * @param {function} cb
   * @returns {Promise}
   * @throws when we have thought to already seeded a result doc, but none found
   */
  _handleNoResult(db, patch) {
    if (this.hasPersistedResult) {
      return Promise.reject(new ReferenceError(
        `no result document match found for doc _id ${this.result._id}`
      ));
    }

    // set `hasPersistedResult` early to prevent race condition
    // if multiple db events enter the system rapidly. e.g. set this bool
    // syncronously in _this_ event loop cycle, so subsequent events see
    // accurate PipelineRunner state.
    this.hasPersistedResult = true;
    assign(this.result, patch);
    return this._persistResult(db);
  }

  /**
   * Persists the result to the db.
   * @private
   * @param {Pouchy} db
   * @returns {Promise}
   */
  _persistResult(db) {
    return db.save(this.result.serialize())
    .then((doc) => {
      this.result._rev = doc._rev; // update our cached result
      return this.result;
    });
  }

  /**
   * Patches the latest ComputationResult with state from
   * last run, then persists
   * @private
   * @param {Pouchy} db
   * @param {object} patch
   * @param {object} doc
   * @returns {Promise}
   */
  _updateResult(db, patch, doc) {
    if (!doc) {
      /* istanbul ignore if */
      if (this.result._rev) {
        throw new ReferenceError('result document not found, yet result has a _rev');
      }
      return this._handleNoResult(db, patch);
    }

    /* istanbul ignore if */
    if (
      this.result.username &amp;&amp; doc.username &amp;&amp; this.result.username !== doc.username
    ) {
      throw new ReferenceError(
        'conflicting usernames exist. stores are not wired properly'
      );
    }

    // build result history on existing results
    this.hasPersistedResult = true;
    assign(this.result, doc, patch);
    if (doc.data !== undefined &amp;&amp; doc.data !== null) {
      this.result.history = doc.history.concat(doc.data);
    }
    return this._persistResult(db);
  }

  /**
   * @abstract
   * @description PipelineRunner subtypes must provide a run function taking
   * a changed document as input, conditionally used by `Pipeline`s to decide
   * how to progress/run the Pipeline itself
   * @throws {ReferenceError} always.
   */
  run() {
    throw new ReferenceError('abstract PipelineRunner must be extended');
  }

  /**
   * Common pipeline run bindings for local and remote runners.
   * @private
   * @param {object} payload
   * @returns {Promise}
   */
  _runPipeline(payload) {
    return this.pipeline.run(payload, this.result)
    .catch((err) => {
      // @note `err` in a pipeline run shouldn't kill our process
      // instead, we sync it into our result
      this.events.emit('error', err);
      return this.saveResult(this.db || this.remoteDB, null, err);
    })
    .then(this._flush.bind(this));
  }
}

PipelineRunner.schema = Object.assign({}, Base.schema, {
  hasPersistedResult: joi.boolean().default(false),
  pipeline: joi.object().type(Pipeline),
  result: joi.object().type(ComputationResult).required(),
});

module.exports = PipelineRunner;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
