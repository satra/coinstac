<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/services/classes/computation-registry.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a><ul class='methods'><li data-type='method'><a href="Base.html#serialize">serialize</a></li><li data-type='method'><a href="Base.html#toJSON">toJSON</a></li></ul></li><li><a href="CommandComputation.html">CommandComputation</a><ul class='methods'><li data-type='method'><a href="CommandComputation.html#run">run</a></li><li data-type='method'><a href="CommandComputation.html#serialize">serialize</a></li><li data-type='method'><a href="CommandComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="Computation.html">Computation</a><ul class='methods'><li data-type='method'><a href="Computation.html#.factory">factory</a></li><li data-type='method'><a href="Computation.html#run">run</a></li><li data-type='method'><a href="Computation.html#serialize">serialize</a></li><li data-type='method'><a href="Computation.html#toJSON">toJSON</a></li></ul></li><li><a href="ComputationRegistry.html">ComputationRegistry</a><ul class='methods'><li data-type='method'><a href="ComputationRegistry.html#.getNameAndVersion">getNameAndVersion</a></li><li data-type='method'><a href="ComputationRegistry.html#add">add</a></li><li data-type='method'><a href="ComputationRegistry.html#all">all</a></li><li data-type='method'><a href="ComputationRegistry.html#get">get</a></li><li data-type='method'><a href="ComputationRegistry.html#remove">remove</a></li></ul></li><li><a href="ComputationResult.html">ComputationResult</a><ul class='methods'><li data-type='method'><a href="ComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="ComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="Consortium.html">Consortium</a><ul class='methods'><li data-type='method'><a href="Consortium.html#.compareUsernames">compareUsernames</a></li><li data-type='method'><a href="Consortium.html#hasMember">hasMember</a></li><li data-type='method'><a href="Consortium.html#isOwnedBy">isOwnedBy</a></li><li data-type='method'><a href="Consortium.html#serialize">serialize</a></li><li data-type='method'><a href="Consortium.html#toJSON">toJSON</a></li></ul></li><li><a href="DBListener.html">DBListener</a><ul class='methods'><li data-type='method'><a href="DBListener.html#destroy">destroy</a></li></ul></li><li><a href="DecentralizedComputation.html">DecentralizedComputation</a><ul class='methods'><li data-type='method'><a href="DecentralizedComputation.html#serialize">serialize</a></li><li data-type='method'><a href="DecentralizedComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="File.html">File</a><ul class='methods'><li data-type='method'><a href="File.html#serialize">serialize</a></li><li data-type='method'><a href="File.html#toJSON">toJSON</a></li></ul></li><li><a href="JavascriptComputation.html">JavascriptComputation</a><ul class='methods'><li data-type='method'><a href="JavascriptComputation.html#run">run</a></li><li data-type='method'><a href="JavascriptComputation.html#serialize">serialize</a></li><li data-type='method'><a href="JavascriptComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalComputationResult.html">LocalComputationResult</a><ul class='methods'><li data-type='method'><a href="LocalComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="LocalComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalPipelineRunner.html">LocalPipelineRunner</a><ul class='methods'><li data-type='method'><a href="LocalPipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="LocalPipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="LocalPipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="LocalPipelineRunner.html#run">run</a></li><li data-type='method'><a href="LocalPipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="LocalPipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="LocalPipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalPipelineRunnerPool.html">LocalPipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="LocalPipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getLatestResult">getLatestResult</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getLocalResult">getLocalResult</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="Pipeline.html">Pipeline</a><ul class='methods'><li data-type='method'><a href="Pipeline.html#run">run</a></li><li data-type='method'><a href="Pipeline.html#serialize">serialize</a></li><li data-type='method'><a href="Pipeline.html#toJSON">toJSON</a></li></ul></li><li><a href="PipelineRunner.html">PipelineRunner</a><ul class='methods'><li data-type='method'><a href="PipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="PipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="PipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="PipelineRunner.html#run">run</a></li><li data-type='method'><a href="PipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="PipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="PipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="PipelineRunnerPool.html">PipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="PipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="PipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="PipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="PipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="PipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="PipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="PipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="PipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="PipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="PipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="PipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="PipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="PouchDocument.html">PouchDocument</a><ul class='methods'><li data-type='method'><a href="PouchDocument.html#serialize">serialize</a></li><li data-type='method'><a href="PouchDocument.html#toJSON">toJSON</a></li></ul></li><li><a href="Project.html">Project</a><ul class='methods'><li data-type='method'><a href="Project.html#serialize">serialize</a></li><li data-type='method'><a href="Project.html#toJSON">toJSON</a></li></ul></li><li><a href="RemoteComputationResult.html">RemoteComputationResult</a><ul class='methods'><li data-type='method'><a href="RemoteComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="RemoteComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="RemotePipelineRunner.html">RemotePipelineRunner</a><ul class='methods'><li data-type='method'><a href="RemotePipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getUserErrors">getUserErrors</a></li><li data-type='method'><a href="RemotePipelineRunner.html#run">run</a></li><li data-type='method'><a href="RemotePipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="RemotePipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="RemotePipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="RemotePipelineRunnerPool.html">RemotePipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="RemotePipelineRunnerPool.html#buildNewRemoteResult">buildNewRemoteResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getLatestResult">getLatestResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getRemoteResult">getRemoteResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="User.html">User</a><ul class='methods'><li data-type='method'><a href="User.html#serialize">serialize</a></li><li data-type='method'><a href="User.html#toJSON">toJSON</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-services_computation-registry-factory.html">services/computation-registry-factory</a><ul class='methods'><li data-type='method'><a href="module-services_computation-registry-factory.html#~computationRegistryFactory">computationRegistryFactory</a></li></ul></li><li><a href="module-services_db-registry.html">services/db-registry</a><ul class='methods'><li data-type='method'><a href="module-services_db-registry.html#~dbRegistryFactory">dbRegistryFactory</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="DBListener.html#event:change">change</a></li><li><a href="DBListener.html#event:delete">delete</a></li><li><a href="LocalPipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="LocalPipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="LocalPipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="LocalPipelineRunnerPool.html#event:ready">ready</a></li><li><a href="LocalPipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="LocalPipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="LocalPipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="LocalPipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="LocalPipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="LocalPipelineRunnerPool.html#event:run:start">run:start</a></li><li><a href="Pipeline.html#event:save-request">save-request</a></li><li><a href="PipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="PipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="PipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="PipelineRunnerPool.html#event:ready">ready</a></li><li><a href="PipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="PipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="PipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="PipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="PipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="PipelineRunnerPool.html#event:run:start">run:start</a></li><li><a href="RemotePipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="RemotePipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="RemotePipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="RemotePipelineRunnerPool.html#event:ready">ready</a></li><li><a href="RemotePipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="RemotePipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="RemotePipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="RemotePipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="RemotePipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="RemotePipelineRunnerPool.html#event:run:start">run:start</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cleanupTestDir">cleanupTestDir</a></li><li><a href="global.html#filterComputation">filterComputation</a></li><li><a href="global.html#getMockComputations">getMockComputations</a></li><li><a href="global.html#localResultOpts">localResultOpts</a></li><li><a href="global.html#MOCK_COMPUTATION_PATH">MOCK_COMPUTATION_PATH</a></li><li><a href="global.html#remoteResultOpts">remoteResultOpts</a></li><li><a href="global.html#seedInstanceComputations">seedInstanceComputations</a></li><li><a href="global.html#setupNetworkStubs">setupNetworkStubs</a></li><li><a href="global.html#setupTestDir">setupTestDir</a></li><li><a href="global.html#TEST_COMPUTATION_PATH">TEST_COMPUTATION_PATH</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">src/services/classes/computation-registry.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const compact = require('lodash/compact');
const concatStream = require('concat-stream');
const DecentralizedComputation =
    require('../../models/decentralized-computation.js');
const fs = require('fs');
const GitHubApi = require('github');
const https = require('https');
const mkdirp = require('mkdirp');
const path = require('path');
const rimraf = require('rimraf');
const spawn = require('child_process').spawn;
const tar = require('tar-fs');
const url = require('url');
const values = require('lodash/values');

/**
 * Get a computation ID from its name and version.
 *
 * @private
 * @param {string} name
 * @param {string} version
 * @returns {string}
 */
function getId(name, version) {
  return `${name}@${version}`;
}

/**
 * Get a registry filter function.
 *
 * @private
 * @param {string} name
 * @param {string} version
 * @returns {function}
 */
function registryFilter(name, version) {
  return function (registryItem) {
    return (
            registryItem.name === name &amp;&amp;
            registryItem.tags.indexOf(version) !== -1
        );
  };
}

/**
 * Find tarball URL from GitHub API response.
 *
 * The GitHub tag API is poorly documented. Response objects aren’t accurate:
 * {@link https://developer.github.com/v3/git/tags/}
 *
 * {@link http://mikedeboer.github.io/node-github/#repos.prototype.getTags}
 *
 * @todo  The GitHub API paginates tags. This function will need to recursively
 * search pages for the tag. There's no tag count/info, so it's impossible to do
 * a binary search. Figure out something!
 * @private
 * @param {object} options
 * @param {GitHubApi} options.github GitHub API client instance
 * @param {string} options.repo Repository name
 * @param {string} options.user Repository owner
 * @param {string} options.version Tag to find
 * @param {string} [options.page=1] API page to search (1-based index)
 * @param {function} callback
 */
function findTarballUrl(options, callback) {
  const github = options.github;
  const repo = options.repo;
  const user = options.user;
  const version = options.version;
  const page = typeof options.page !== 'undefined' ? options.page : 1;

  github.repos.getTags({
    page,
    per_page: 100,
    repo,
    user,
  }, (err, res) => {
    if (err) { return callback(err); }

    const tag = res.find(t => t.name === 'v' + version);

    // Potentially recurse here
    if (!tag) {
      return callback(new Error(
        `Couldn’t find tag for ${user}/${repo}@${version}`
      ));
    }
    return callback(null, tag.tarball_url); // jshint ignore:line
  });
}

/**
 * Get a computation's tarball URL.
 * @private
 * @param {object} options
 * @param {GitHubApi} options.github GitHub API client instance
 * @param {string} options.name
 * @param {object[]} options.registry
 * @param {string} options.version
 * @returns {Promise}
 */
function getTarballUrl(options) {
  const github = options.github;
  const name = options.name;
  const registry = options.registry;
  const version = options.version;

  const registryItem = registry.find(registryFilter(name, version));

  if (!registryItem) {
    return Promise.reject(new Error(
            `Couldn’t find URL for ${getId(name, version)}`
        ));
  }

    /**
     * @todo  This expects `registryItem.url` to be a GitHub URL. Expand to be
     * more flexible.
     */
  const pathPieces = compact(url.parse(registryItem.url).path.split('/'));

  return new Promise((resolve, reject) => {
    findTarballUrl({
      github,
      repo: pathPieces[1],
      user: pathPieces[0],
      version,
    }, (err, tarballUrl) => {
      if (err) {
        return reject(err);
      }

      return resolve(tarballUrl);
    });
  });
}

/**
 * Run `npm install` on a path.
 * @private
 * @param {string} path
 * @returns {Promise}
 */
function runNPMInstall(path) {
  return new Promise((resolve, reject) => {
    const child = spawn('npm', ['install', '--production'], { cwd: path });

    let error;
    let out;

    child.stderr.pipe(concatStream(data => {
      error = data.toString();
    }));
    child.stdout.pipe(concatStream(data => {
      out = data.toString();
    }));

    child.on('close', exitCode => {
      /* istanbul ignore if */
      if (exitCode) {
        return reject(error);
      }
      return resolve(out);
    });
  });
}

/**
 * Computation registry.
 * @class
 *
 * @example
 * const instance = new ComputationRegistry({
 *   github: new GitHubApi({...}),
 *   path: path.join(__dirname, 'computations'),
 *   registry: [{
 *     name: 'my-computation',
 *     tags: ['1.0.0'],
 *     url: 'https://github.com/MRN-Code/coinstac-my-computation',
 *   }, {
 *     name: 'my-other-computation',
 *     tags: ['0.5.1', '0.6.0'],
 *     url: 'https://github.com/MRN-Code/coinstac-my-other-computation',
 *   }],
 * });
 *
 * @param {object} options
 * @param {GitHubApi} options.github GitHub API client instance
 * @param {string} options.path Path on disk to cache computations
 * @param {object[]} options.registry Collection of computation registry objects
 */
function ComputationRegistry(options) {
  if (!options.github || !(options.github instanceof GitHubApi)) {
    throw new TypeError('Expected GitHubApi instance');
  }

  if (!options.path) {
    throw new TypeError('Expected path');
  }

  if (!options.registry || !Array.isArray(options.registry)) {
    throw new TypeError('Expected registry of computations');
  }

  this.github = options.github;
  this.path = options.path;
  this.registry = options.registry;
  this.store = {};
}

/**
 * Actually add a computation to the store.
 * @private
 * @param {string} name
 * @param {string} version
 * @param {object} definition Raw computation definition
 * @returns {Promise} Resolves to `DecentralizedComputation` if match is found
 */
ComputationRegistry.prototype._doAdd = function (name, version, definition) {
  const model = new DecentralizedComputation(definition);

  model.cwd = definition.cwd || this._getComputationPath(name, version);

  this.store[getId(name, version)] = model;
  return this.get(name, version);
};

/**
 * Get a computation's path on disk.
 * @private
 * @param {string} name
 * @param {string} version
 * @returns {string}
 */
ComputationRegistry.prototype._getComputationPath = function (name, version) {
  return path.join(this.path, '/' + getId(name, version));
};

/**
 * Get a computation definition from disk.
 * @private
 * @param {string} name
 * @param {string} version
 * @returns {Promise}
 */
ComputationRegistry.prototype._getFromDisk = function (name, version) {
  const computationPath = this._getComputationPath(name, version);

  return new Promise((resolve, reject) => {
    fs.stat(computationPath, (err) => {
      if (err) {
        return reject(err);
      }

      try {
        resolve(require(computationPath));
      } catch (error) {
        reject(error);
      }
      return null;
    });
  });
};

/**
 * Get a computation definition from source (the web).
 *
 * This has a side effect of saving the computation definition to disk.
 * @private
 * @param {string} name
 * @param {string} version
 * @returns {Promise}
 */
ComputationRegistry.prototype._getFromSource = function (name, version) {
  const path = this._getComputationPath(name, version);

  return getTarballUrl({
    github: this.github,
    name,
    registry: this.registry,
    version,
  })
  .then(tarballUrl => {
    return new Promise((resolve, reject) => {
      mkdirp(path, (err) => {
        if (err) { return reject(err); }

        const tarExtract = tar.extract(path);
        const request = https.request(tarballUrl).pipe(tarExtract);

        request.on('error', reject);
        return tarExtract.on('finish', resolve);
      });
    });
  })
  .then(() => runNPMInstall(path))
  .then(() => this._getFromDisk(name, version));
};

/**
 * Add a decentralized computation to the store.
 *
 * @param {string} name
 * @param {string} version
 * @returns {Promise}
 */
ComputationRegistry.prototype.add = function (name, version) {
  const isValid = this.registry.some(registryFilter(name, version));

  function doAdd(definition) {
    return this._doAdd(name, version, definition); // jshint ignore:line
  }

    // Check registry to make sure name/version is valid
  if (!isValid) {
    return Promise.reject(new Error(
            `computation ${getId(name, version)} not in registry`
        ));
  }

    // Check the store to see if computation exists
  return this.get(name, version)

        // Check disk to see if computation is saved
        .catch(() => {
          return this._getFromDisk(name, version).then(doAdd.bind(this));
        })

        // Download computation from source, save to Disk
        .catch(() => {
          return this._getFromSource(name, version).then(doAdd.bind(this));
        });
};

/**
 * Get all decentralized computations from store.
 *
 * @returns {Promise}
 */
ComputationRegistry.prototype.all = function () {
  return Promise.resolve(values(this.store));
};

/**
 * Get a single decentralized computation from store.
 *
 * @param {string} name
 * @param {string} version
 * @returns {Promise} Resolves to `DecentralizedComputation` if match is found
 */
ComputationRegistry.prototype.get = function (name, version) {
  if (!name || !version) {
    return Promise.reject(new TypeError('expected name and version'));
  }

  const id = getId(name, version);

  if (!(id in this.store)) {
    return Promise.reject(new Error(
            `computation ${getId(name, version)} not in registry`
        ));
  }

  return Promise.resolve(this.store[id]);
};

/**
 * Remove a computation.
 *
 * @param {string} name
 * @param {string} version
 * @param {boolean} [fromDisk=false] Remove cached computation from disk
 * @returns {Promise}
 */
ComputationRegistry.prototype.remove = function (name, version, fromDisk) {
  const id = getId(name, version);

  if (!(id in this.store)) {
    return Promise.reject(new Error(
            `Computation ${id} not in registry`
        ));
  }

  delete this.store[id];

  if (!fromDisk) {
    return Promise.resolve();
  }

  return new Promise((resolve, reject) => {
    rimraf(this._getComputationPath(name, version), (err, res) => {
      if (err) { return reject(err); }
      return resolve(res);
    });
  });
};

// TODO:  improve/test pattern
ComputationRegistry.DIRECTORY_PATTERN = /^([\w-\.]+)@([\w-\.]+)$/;

/**
 * Get a computation's name and version from its directory.
 *
 * @todo  Test it
 * @static
 * @param {string} directory
 * @returns {(array|null)}
 */
ComputationRegistry.getNameAndVersion = function (directory) {
  const matches = directory.match(ComputationRegistry.DIRECTORY_PATTERN);
  if (matches) {
    return [matches[1], matches[2]];
  }
  return null;
};

module.exports = ComputationRegistry;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
