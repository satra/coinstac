<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test/services/computation-registry.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a><ul class='methods'><li data-type='method'><a href="Base.html#serialize">serialize</a></li><li data-type='method'><a href="Base.html#toJSON">toJSON</a></li></ul></li><li><a href="CommandComputation.html">CommandComputation</a><ul class='methods'><li data-type='method'><a href="CommandComputation.html#run">run</a></li><li data-type='method'><a href="CommandComputation.html#serialize">serialize</a></li><li data-type='method'><a href="CommandComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="Computation.html">Computation</a><ul class='methods'><li data-type='method'><a href="Computation.html#.factory">factory</a></li><li data-type='method'><a href="Computation.html#run">run</a></li><li data-type='method'><a href="Computation.html#serialize">serialize</a></li><li data-type='method'><a href="Computation.html#toJSON">toJSON</a></li></ul></li><li><a href="ComputationRegistry.html">ComputationRegistry</a><ul class='methods'><li data-type='method'><a href="ComputationRegistry.html#.getNameAndVersion">getNameAndVersion</a></li><li data-type='method'><a href="ComputationRegistry.html#add">add</a></li><li data-type='method'><a href="ComputationRegistry.html#all">all</a></li><li data-type='method'><a href="ComputationRegistry.html#get">get</a></li><li data-type='method'><a href="ComputationRegistry.html#remove">remove</a></li></ul></li><li><a href="ComputationResult.html">ComputationResult</a><ul class='methods'><li data-type='method'><a href="ComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="ComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="Consortium.html">Consortium</a><ul class='methods'><li data-type='method'><a href="Consortium.html#.compareUsernames">compareUsernames</a></li><li data-type='method'><a href="Consortium.html#hasMember">hasMember</a></li><li data-type='method'><a href="Consortium.html#isOwnedBy">isOwnedBy</a></li><li data-type='method'><a href="Consortium.html#serialize">serialize</a></li><li data-type='method'><a href="Consortium.html#toJSON">toJSON</a></li></ul></li><li><a href="DBListener.html">DBListener</a><ul class='methods'><li data-type='method'><a href="DBListener.html#destroy">destroy</a></li></ul></li><li><a href="DecentralizedComputation.html">DecentralizedComputation</a><ul class='methods'><li data-type='method'><a href="DecentralizedComputation.html#serialize">serialize</a></li><li data-type='method'><a href="DecentralizedComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="File.html">File</a><ul class='methods'><li data-type='method'><a href="File.html#serialize">serialize</a></li><li data-type='method'><a href="File.html#toJSON">toJSON</a></li></ul></li><li><a href="JavascriptComputation.html">JavascriptComputation</a><ul class='methods'><li data-type='method'><a href="JavascriptComputation.html#run">run</a></li><li data-type='method'><a href="JavascriptComputation.html#serialize">serialize</a></li><li data-type='method'><a href="JavascriptComputation.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalComputationResult.html">LocalComputationResult</a><ul class='methods'><li data-type='method'><a href="LocalComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="LocalComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalPipelineRunner.html">LocalPipelineRunner</a><ul class='methods'><li data-type='method'><a href="LocalPipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="LocalPipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="LocalPipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="LocalPipelineRunner.html#run">run</a></li><li data-type='method'><a href="LocalPipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="LocalPipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="LocalPipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="LocalPipelineRunnerPool.html">LocalPipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="LocalPipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getLatestResult">getLatestResult</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getLocalResult">getLocalResult</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="LocalPipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="Pipeline.html">Pipeline</a><ul class='methods'><li data-type='method'><a href="Pipeline.html#run">run</a></li><li data-type='method'><a href="Pipeline.html#serialize">serialize</a></li><li data-type='method'><a href="Pipeline.html#toJSON">toJSON</a></li></ul></li><li><a href="PipelineRunner.html">PipelineRunner</a><ul class='methods'><li data-type='method'><a href="PipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="PipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="PipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="PipelineRunner.html#run">run</a></li><li data-type='method'><a href="PipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="PipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="PipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="PipelineRunnerPool.html">PipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="PipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="PipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="PipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="PipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="PipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="PipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="PipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="PipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="PipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="PipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="PipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="PipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="PouchDocument.html">PouchDocument</a><ul class='methods'><li data-type='method'><a href="PouchDocument.html#serialize">serialize</a></li><li data-type='method'><a href="PouchDocument.html#toJSON">toJSON</a></li></ul></li><li><a href="Project.html">Project</a><ul class='methods'><li data-type='method'><a href="Project.html#serialize">serialize</a></li><li data-type='method'><a href="Project.html#toJSON">toJSON</a></li></ul></li><li><a href="RemoteComputationResult.html">RemoteComputationResult</a><ul class='methods'><li data-type='method'><a href="RemoteComputationResult.html#serialize">serialize</a></li><li data-type='method'><a href="RemoteComputationResult.html#toJSON">toJSON</a></li></ul></li><li><a href="RemotePipelineRunner.html">RemotePipelineRunner</a><ul class='methods'><li data-type='method'><a href="RemotePipelineRunner.html#findResultByRunId">findResultByRunId</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getPreviousResultData">getPreviousResultData</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getResultDocs">getResultDocs</a></li><li data-type='method'><a href="RemotePipelineRunner.html#getUserErrors">getUserErrors</a></li><li data-type='method'><a href="RemotePipelineRunner.html#run">run</a></li><li data-type='method'><a href="RemotePipelineRunner.html#saveResult">saveResult</a></li><li data-type='method'><a href="RemotePipelineRunner.html#serialize">serialize</a></li><li data-type='method'><a href="RemotePipelineRunner.html#toJSON">toJSON</a></li></ul></li><li><a href="RemotePipelineRunnerPool.html">RemotePipelineRunnerPool</a><ul class='methods'><li data-type='method'><a href="RemotePipelineRunnerPool.html#buildNewRemoteResult">buildNewRemoteResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#createNewRunner">createNewRunner</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#destroy">destroy</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getDecentralizedComputation">getDecentralizedComputation</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getLatestResult">getLatestResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getPipelinePlugins">getPipelinePlugins</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#getRemoteResult">getRemoteResult</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#handleResultChange">handleResultChange</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#init">init</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#listenToConsortia">listenToConsortia</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#serialize">serialize</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#toJSON">toJSON</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#triggerRunner">triggerRunner</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#unlistenToConsortia">unlistenToConsortia</a></li><li data-type='method'><a href="RemotePipelineRunnerPool.html#upsertListener">upsertListener</a></li></ul></li><li><a href="User.html">User</a><ul class='methods'><li data-type='method'><a href="User.html#serialize">serialize</a></li><li data-type='method'><a href="User.html#toJSON">toJSON</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-services_computation-registry-factory.html">services/computation-registry-factory</a><ul class='methods'><li data-type='method'><a href="module-services_computation-registry-factory.html#~computationRegistryFactory">computationRegistryFactory</a></li></ul></li><li><a href="module-services_db-registry.html">services/db-registry</a><ul class='methods'><li data-type='method'><a href="module-services_db-registry.html#~dbRegistryFactory">dbRegistryFactory</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="DBListener.html#event:change">change</a></li><li><a href="DBListener.html#event:delete">delete</a></li><li><a href="LocalPipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="LocalPipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="LocalPipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="LocalPipelineRunnerPool.html#event:ready">ready</a></li><li><a href="LocalPipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="LocalPipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="LocalPipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="LocalPipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="LocalPipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="LocalPipelineRunnerPool.html#event:run:start">run:start</a></li><li><a href="Pipeline.html#event:save-request">save-request</a></li><li><a href="PipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="PipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="PipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="PipelineRunnerPool.html#event:ready">ready</a></li><li><a href="PipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="PipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="PipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="PipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="PipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="PipelineRunnerPool.html#event:run:start">run:start</a></li><li><a href="RemotePipelineRunner.html#event:noop:noData">noop:noData</a></li><li><a href="RemotePipelineRunner.html#event:noop:noStateChange">noop:noStateChange</a></li><li><a href="RemotePipelineRunnerPool.html#event:computation:complete">computation:complete</a></li><li><a href="RemotePipelineRunnerPool.html#event:ready">ready</a></li><li><a href="RemotePipelineRunnerPool.html#event:listener:created">listener:created</a></li><li><a href="RemotePipelineRunnerPool.html#event:pipeline:inProgress">pipeline:inProgress</a></li><li><a href="RemotePipelineRunnerPool.html#event:queue:end">queue:end</a></li><li><a href="RemotePipelineRunnerPool.html#event:queue:start">queue:start</a></li><li><a href="RemotePipelineRunnerPool.html#event:run:end">run:end</a></li><li><a href="RemotePipelineRunnerPool.html#event:run:start">run:start</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cleanupTestDir">cleanupTestDir</a></li><li><a href="global.html#filterComputation">filterComputation</a></li><li><a href="global.html#getMockComputations">getMockComputations</a></li><li><a href="global.html#localResultOpts">localResultOpts</a></li><li><a href="global.html#MOCK_COMPUTATION_PATH">MOCK_COMPUTATION_PATH</a></li><li><a href="global.html#remoteResultOpts">remoteResultOpts</a></li><li><a href="global.html#seedInstanceComputations">seedInstanceComputations</a></li><li><a href="global.html#setupNetworkStubs">setupNetworkStubs</a></li><li><a href="global.html#setupTestDir">setupTestDir</a></li><li><a href="global.html#TEST_COMPUTATION_PATH">TEST_COMPUTATION_PATH</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">test/services/computation-registry.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const assign = require('lodash/assign');
const ComputationRegistry =
    require('../../src/services/classes/computation-registry');
const DecentralizedComputation =
    require('../../src/models/decentralized-computation');
const fs = require('fs');
const GitHubApi = require('github');
const helpers = require('../helpers/computation-registry-helpers.js');
const https = require('https');
const mockApiTagResponse = require('../mocks/api-tag-response.json');
const path = require('path');
const registry = require('../mocks/decentralized-computations.json');
const sinon = require('sinon');
const tape = require('tape');
const tar = require('tar-fs');
const values = require('lodash/values');

const github = new GitHubApi({ version: '3.0.0' });
const MOCK_COMPUTATION_PATH = helpers.MOCK_COMPUTATION_PATH;
const TEST_COMPUTATION_PATH = helpers.TEST_COMPUTATION_PATH;

// Get a configured ComputationRegistry class
function factory(options) {
  const defaults = {
    github,
    path: TEST_COMPUTATION_PATH,
    registry,
  };

  return new ComputationRegistry(assign({}, defaults, options));
}

/**
 * Get mock computations.
 *
 * @returns {DecentralizedComputation[]} seeded mock computations
 */
function getMockComputations() {
  return registry.reduce((all, registryItem) => {
    all = all.concat(registryItem.tags.map(tag => {
      return new DecentralizedComputation({
        cwd: path.join(
            TEST_COMPUTATION_PATH,
            `${registryItem.name}@${tag}`
          ),
        local: {},
        name: registryItem.name,
        remote: {},
        repository: {
          url: registryItem.url,
        },
        version: tag,
      });
    }));

    return all;
  }, []);
}

/**
 * Seed a ComputationRegistry instance's computations store.
 *
 * @todo Figure out a more elegant way to stock the store.
 *
 * @param {ComputationRegistry} instance
 * @param {DecentralizedComputation[]} computations
 */
function seedInstanceComputations(instance, computations) {
  computations.forEach(c => {
    instance.store[`${c.name}@${c.version}`] = c; // eslint-disable-line
  });
}

/**
 * Set up network stubs.
 *
 * Wraps the GitHub API’s `getTags` method and `request`. User must call
 * sinon’s `restore()` on each stub.
 *
 * @param {string} computationSlug A &lt;name>@&lt;version> slug that matches to a
 * mock computation's directory name. This is used on requests to pack a tarball
 * from the directory's contents.
 * @returns {object}
 * @property {function} githubStub
 * @property {function} requestStub
 */
function setupNetworkStubs(computationSlug) {
  const githubStub = sinon.stub(github.repos, 'getTags');
  const requestStub = sinon.stub(https, 'request');

  githubStub.yields(null, mockApiTagResponse);
  requestStub.returns(tar.pack(
        path.join(MOCK_COMPUTATION_PATH, computationSlug)
    ));

  return { githubStub, requestStub };
}

/**
 * Get a computation filter function.
 *
 * @param {string} name
 * @param {string} version Semver version
 * @returns {function}
 */
function filterComputation(name, version) {
  return function _filterComputation(computation) {
    return computation.name === name &amp;&amp; computation.version === version;
  };
}

tape('constructor', t => {
  function badFactory(options) {
    return new ComputationRegistry(options || {});
  }

  t.throws(badFactory, /github/gi, 'throws with no GitHub API client');
  t.throws(
    badFactory.bind(null, { github }),
    /path/gi,
    'throws with no path'
  );
  t.throws(
    badFactory.bind(null, { github, path }),
    /registry/gi,
    'throws with no registry'
  );

  t.doesNotThrow(factory, 'works with proper args');

  const instance = factory();

  t.ok(
        (
            instance.github === github &amp;&amp;
            instance.path === TEST_COMPUTATION_PATH &amp;&amp;
            instance.registry === registry
        ),
        'sets instance properties'
    );
  t.end();
});

tape('adds definition to store', t => {
  t.plan(3);

  const instance = factory({ registry: [] });
  const name = registry[0].name;
  const version = registry[0].tags[1];
  const definition = require(`${MOCK_COMPUTATION_PATH}/${name}@${version}/`);

  instance._doAdd(name, version, definition)
  .then(computation => {
    t.ok(
      computation instanceof DecentralizedComputation,
      'returns DecentralizedComputation instance'
    );
    t.ok(
          (
              computation.name === name &amp;&amp;
              computation.version === version
          ),
          'instance name and version match'
      );
    t.ok(
          values(instance.store)[0] === computation,
          'saves DecentralizedComputation to internal store'
      );
  })
  .catch(t.end);
});

tape('sets definition’s cwd on model', t => {
  t.plan(1);

  const instance = factory();
  const name = registry[0].name;
  const version = registry[0].tags[1];

  const definition = {
    local: {
      type: 'function',
      fn: () => 1,
    },
    name,
    repository: {
      url: 'https://github.com/MRN-Code',
    },
    remote: {
      type: 'function',
      fn: () => 2,
    },
    setup: cb => cb(null, true),
    version,
  };

  instance._doAdd(name, version, definition)
  .then(computation => {
    t.equal(
      computation.cwd,
      path.join(instance.path, `${name}@${version}`),
      'sets cwd on string setup'
    );
  })
  .catch(t.end);
});

tape('gets computation path', t => {
  const instance = factory();
  const name = registry[0].name;
  const version = registry[0].tags[1];

  const computationPath = instance._getComputationPath(name, version);

  t.ok(
    computationPath.indexOf(TEST_COMPUTATION_PATH) !== -1,
    'contains path'
  );
  t.ok(computationPath.indexOf(name) !== -1, 'contains name');
  t.ok(computationPath.indexOf(version) !== -1, 'contains version');
  t.end();
});

tape('gets definition from disk', t => {
  t.plan(1);

  const instance = factory({
    path: MOCK_COMPUTATION_PATH,
    registry: [],
  });
  const name = registry[0].name;
  const version = registry[0].tags[1];
  const expected = require(`${MOCK_COMPUTATION_PATH}/${name}@${version}/`);

  instance._getFromDisk(name, version)
  .then(definition => {
    t.deepEqual(definition, expected, 'definition matches');
  })
  .catch(t.end);
});

tape('gets computation from source', t => {
  t.plan(7);

  const instance = factory();
  const name = registry[2].name;
  const version = registry[2].tags[0];

  const slug = `${name}@${version}`;
  const stubs = setupNetworkStubs(slug);
  const githubStub = stubs.githubStub;
  const requestStub = stubs.requestStub;

    // Expected tarball URL, taken from the mock JSON
  const tarballUrl =
    `https://api.github.com/repos/MRN-Code/${name}/tarball/v${version}`;

  instance._getFromSource(name, version)
  .then(res => {
    t.ok(
      res.name === name &amp;&amp; res.version === version,
      'returns computation definition'
    );

    const args = githubStub.firstCall.args[0];

    t.ok(
      (
          args.page === 1 &amp;&amp;
          args.repo === name &amp;&amp;
          args.user === 'MRN-Code'
      ),
      'calls getTags() with right args'
    );

    t.equal(
      requestStub.firstCall.args[0],
      tarballUrl,
      'requests expected tarball'
    );

    fs.readdir(TEST_COMPUTATION_PATH, (err, computations) => { // eslint-disable-line
      if (err) {
        return t.end(err);
      }

      t.ok(
        computations.indexOf(slug) !== -1,
        'unpacks tarball in expected directory'
      );

      fs.readdir(
        path.join(TEST_COMPUTATION_PATH, slug),
        (err, files) => {
          if (err) { return t.end(err); }
          const requiredFiles = ['index.js', 'package.json'];
          t.ok(
            requiredFiles.every(f => files.indexOf(f) !== -1) &amp;&amp;
            files.every(f => {
              return (
                requiredFiles.indexOf(f) !== -1 ||
                f === 'node_modules'
              );
            }),
            'unpacks all computation files'
          );

          return fs.readdir(
            path.join(TEST_COMPUTATION_PATH, slug, 'node_modules'),
            (err, nodeModules) => {
              if (err) { return t.end(err); }
              t.ok(
                nodeModules.length === 1 &amp;&amp;
                nodeModules[0] === 'lodash',
                'installs dependencies via NPM'
              );
              // Cleanup
              githubStub.restore();
              return requestStub.restore();
            }
          );
        }
      );
    });
  })
  .then(helpers.cleanupTestDir)

  // Remove temporary test computation directory
  .then(() => t.pass('test cleanup'))
  .catch(error => {
    t.end(error);
  });
});

tape('handles GitHub API errors', t => {
  t.plan(1);

  const githubStub = sinon.stub(github.repos, 'getTags');
  const instance = factory();

  githubStub.yields(new Error('bananas'));

  instance._getFromSource(registry[2].name, registry[2].tags[0])
        .then(() => t.fail('expected GitHub API error'))
        .catch(error => {
          t.equal(error.message, 'bananas', 'handles GitHub API error');
          githubStub.restore();
        });
});

tape('handles non-existant GitHub API tag', t => {
  t.plan(1);

  const githubStub = sinon.stub(github.repos, 'getTags');
  const instance = factory();
  const name = registry[2].name;
  const version = registry[2].tags[0];

  githubStub.yields(null, []);

  instance._getFromSource(name, version)
        .then(() => t.fail('expected no present tag'))
        .catch(error => {
          const message = error.message;

          t.ok(
                message.indexOf(name) !== -1 &amp;&amp;
                message.indexOf(version) !== -1,
                'errors with name and tag (version)'
            );

          githubStub.restore();
        });
});

tape('adds computation that isn’t registered', t => {
  t.plan(1);

  const instance = factory();

  instance.add('bananas', 'are yummy')
        .then(() => t.fail('expected to reject'))
        .catch(() => {
          t.ok('rejects on non-registry name/version');
        });
});

tape('add a computation (gets from memory)', t => {
  t.plan(1);

  const instance = factory();
  const mockComputations = getMockComputations();
  const name = registry[1].name;
  const version = registry[1].tags[0];

  const computation = mockComputations.find(
        filterComputation(name, version)
    );

    // Setup
  instance._doAdd(name, version, computation)
        .then(() => instance.add(name, version))
        .then(response => {
            // `response` and expected `computation` are different instances
          t.deepEqual(
                response.serialize(),
                computation.serialize(),
                'gets computation from memory'
            );
        })
        .catch(t.end);
});

tape('add a computation (gets from disk)', t => {
  t.plan(4);

  const instance = factory();
  const name = 'the-ravens';
  const version = '2.0.0';

  const slug = name + '@' + version;
  const stubs = setupNetworkStubs(slug);
  const githubStub = stubs.githubStub;
  const requestStub = stubs.requestStub;

  helpers.setupTestDir(slug)
        .then(() => instance.add(name, version))
        .then(response => {
            // Check that `response` matches the mock computation definition
            // (see) the-ravens@2.0.0/index.js
          t.ok(
                (
                    response.name === name &amp;&amp;
                    response.version === version &amp;&amp;
                    response.remote.fn instanceof Function &amp;&amp;
                    response.local.fn instanceof Function
                ),
                'gets computation from disk'
            );

          t.notOk(githubStub.callCount, 'doesn’t call GitHub API');
          t.notOk(requestStub.callCount, 'doesn’t download tarball');

          githubStub.restore();
          requestStub.restore();
        })
        .catch(t.end)
        .then(helpers.cleanupTestDir)
        .then(() => t.pass('test cleanup'));
});

tape('add a computation (gets from network)', t => {
  t.plan(5);

  const instance = factory();
  const name = 'a-small-bag';

    /**
     * Node uses `fs.stat` behind the scenes to see if a `require`-d path
     * exists. By asserting this spy is called before network activiy we can
     * test that a disk search was executed first.
     *
     * {@link https://github.com/nodejs/node/blob/master/lib/module.js}
     */
  const statSpy = sinon.spy(fs, 'stat');
  const version = '1.0.0-beta';

  const expectedUrl =
        `https://api.github.com/repos/MRN-Code/${name}/tarball/v${version}`;
  const slug = name + '@' + version;
  const stubs = setupNetworkStubs(slug);
  const githubStub = stubs.githubStub;
  const requestStub = stubs.requestStub;

  instance.add(name, version)
        .then(response => {
          t.ok(
                statSpy.calledWith(path.join(TEST_COMPUTATION_PATH, slug)) &amp;&amp;
                statSpy.calledBefore(githubStub),
                'checks filesystem before going to network'
            );
          t.ok(
                (
                    githubStub.callCount === 1 &amp;&amp;
                    githubStub.firstCall.args[0].repo === name
                ),
                'calls GitHub API'
            );
          t.equal(
                requestStub.firstCall.args[0],
                expectedUrl,
                'downloads computation from source'
            );
          t.ok(
                (
                    response.name === name &amp;&amp;
                    response.version === version &amp;&amp;
                    response.remote.fn instanceof Function &amp;&amp;
                    response.local.fn instanceof Function
                ),
                'gets computation from network'
            );

          githubStub.restore();
          requestStub.restore();
          statSpy.restore();
        })
        .catch(t.end)
        .then(helpers.cleanupTestDir)
        .then(() => t.pass('test cleanup'));
});

tape('gets all stored computations', t => {
  t.plan(2);

  const instance = factory();
  const mockComputations = getMockComputations();

  seedInstanceComputations(instance, mockComputations);

  instance.all()
        .then(computations => {
          t.ok(computations.length, 'returns *some* computations');
          t.deepEqual(
                computations,
                mockComputations,
                'returns all stored computations'
            );
        })
        .catch(t.end);
});

tape('get fails on with no computation name', t => {
  t.plan(1);

  factory().get()
        .then(() => t.fail('expected to reject without args'))
        .catch(() => t.pass('rejects without args'));
});

tape('get fails on with no computation name', t => {
  t.plan(1);

  factory().get('bananas')
        .then(() => t.fail('expected no version to reject'))
        .catch(() => t.pass('rejects without version'));
});

tape('gets computation by name and version', t => {
  t.plan(2);

  const instance = factory();
  const mockComputations = getMockComputations();
  const name = registry[0].name;
  const version = registry[0].tags[0];

  seedInstanceComputations(instance, mockComputations);

  instance.get('bogus-name', 'what is a version even')
        .then(() => {
          t.fail('returned bogus computation');
        })
        .catch(error => {
          t.ok(error, 'errored on bogus computation name');
        });

  instance.get(name, version)
        .then(computation => {
          t.ok(
                (
                    computation.name === name &amp;&amp;
                    computation.version === version
                ),
                'gets computation by name and version'
            );
        })
        .catch(t.end);
});

tape('doesn’t remove unknown computation', t => {
  t.plan(1);

  factory().remove('bogus-name', 'what-is-version')
        .then(() => t.fail('expected bad name/version to reject'))
        .catch(() => t.pass('errored on bad name/version'));
});

tape('remove computation from store', t => {
  t.plan(1);

  const instance = factory();
  const mockComputations = getMockComputations();
  const name = registry[0].name;
  const version = registry[0].tags[0];

  seedInstanceComputations(instance, mockComputations);

  instance.remove(name, version)
  .then(() => {
    t.ok(
      values(instance.store).every(c => {
        return !(c.name === name &amp;&amp; c.version === version);
      }),
      'computation removed'
    );
  })
  .catch(t.end);
});

tape('remove computation from disk', t => {
  t.plan(3);

  const instance = factory();
  const name = 'a-small-bag';
  const version = '1.0.0-beta';
  const slug = name + '@' + version;
  const stubs = setupNetworkStubs(slug);

  instance.add(name, version)
  .then(computation => {
    t.ok(computation, 'gets computation');
    stubs.githubStub.restore();
    stubs.requestStub.restore();
    return instance.remove(name, version, true);
  })
  .then(() => {
    fs.readdir(TEST_COMPUTATION_PATH, (err, files) => {
      if (err) { return t.end(err); }
      return t.ok(
        files.indexOf(slug) === -1,
        'removes computation from disk'
      );
    });
  })
  .catch(t.end)
  .then(() => helpers.cleanupTestDir())
  .then(() => t.pass('test cleanup'));
});

tape('gets name and version from directory name', t => {
  const get = ComputationRegistry.getNameAndVersion;
  t.deepEqual(get('whatsup@1.0.0'), ['whatsup', '1.0.0']);
  t.deepEqual(
    get('My_Fanciness--200@5.30.1'),
    ['My_Fanciness--200', '5.30.1']
  );
  t.deepEqual(
    get('banana-guards@0.5.1-beta'),
    ['banana-guards', '0.5.1-beta']
  );
  t.end();
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
